1. Escenario & Reto
Tras la √©pica batalla mental entre el Gato y el Rat√≥n, algo inesperado ocurri√≥.

El laboratorio subterr√°neo donde se libr√≥ su duelo empez√≥ a temblar. Las luces parpadearon, las pantallas mostraron s√≠mbolos extra√±os, y justo cuando pensabas que era el final‚Ä¶ un nuevo archivo apareci√≥ misteriosamente en tu carpeta de proyectos:

laberinto.c

Al abrirlo, encuentras solo una l√≠nea:

"Este es solo el comienzo. Escapa si puedes."

Ahora est√°s atrapado en un nuevo reto: el Laberinto Maestro, un mundo generado por c√≥digo donde cada paso puede llevarte a la libertad‚Ä¶ o a una pared.

Tu misi√≥n, valiente desarrollador, es crear un generador de laberintos aleatorios totalmente resolubles, y luego dise√±ar un algoritmo que los resuelva autom√°ticamente. Esto no es un simple mapa: es un desaf√≠o de l√≥gica, dise√±o y optimizaci√≥n que solo un verdadero estratega del c√≥digo puede superar.

¬øLograr√°s construir el camino hacia la salida? ¬øO te perder√°s en tu propio c√≥digo?

2. Habilidades que Vas a Necesitar
Programaci√≥n estructurada en C o C++ (el lenguaje cl√°sico de los valientes).

Backtracking y BFS (porque no todo en la vida se resuelve con fuerza bruta).

Dise√±o algor√≠tmico para generar estructuras l√≥gicas sin callejones sin salida.

Visualizaci√≥n creativa con ASCII o emojis (¬°s√≠, programar tambi√©n puede ser bonito!).

Optimizaci√≥n de recursos y tiempos de ejecuci√≥n (porque hasta los laberintos tienen deadlines).

3. Requisitos Obligatorios (Tu Mapa de Supervivencia)
Generaci√≥n del Laberinto:
El laberinto debe ser generado de forma aleatoria en cada ejecuci√≥n.

Debe tener una entrada (esquina superior izquierda) y una salida (esquina inferior derecha), siempre conectadas.

Aseg√∫rate de que haya al menos un camino v√°lido entre ambos extremos.

Resoluci√≥n Autom√°tica del Laberinto:
Implementa un algoritmo que resuelva autom√°ticamente el laberinto.

Puedes usar Backtracking, BFS o cualquier enfoque l√≥gico que te lleve al √©xito.

Tama√±o Configurable:
El laberinto debe comenzar con un tama√±o fijo (por ejemplo, 10x10).

Luego, modif√≠calo para que su tama√±o se defina con par√°metros externos, sin tocar el c√≥digo fuente.

Visualizaci√≥n Clara:
Representa el laberinto en consola usando caracteres ASCII o emojis.

Muros: #

Caminos: *

Entrada y salida marcadas claramente.

La visualizaci√≥n debe permitir ver el recorrido resuelto.

Organizaci√≥n & Optimizaci√≥n:
Separa el programa en partes claras:

Generaci√≥n del laberinto

Visualizaci√≥n

Resoluci√≥n

Toma mediciones de tiempo de ejecuci√≥n para laberintos de distintos tama√±os.

Usa estructuras de datos eficientes para velocidad y legibilidad.

4. Entregables, Reglas y Bonus Opcionales
Entregables:

Un archivo .c o .cpp con tu implementaci√≥n.

Un README corto explicando:

C√≥mo generaste el laberinto.

Qu√© algoritmo usaste para resolverlo.

Qu√© descubriste al medir tiempos y qu√© har√≠as distinto la pr√≥xima vez.

Reglas:

No se permite usar bibliotecas externas para generaci√≥n o resoluci√≥n autom√°tica. Este reto se resuelve con c√≥digo propio y creatividad.

El c√≥digo debe ser legible, comentado y modular.

Bonus Opcionales:

A√±ade obst√°culos especiales (puertas, trampas, portales).

Agrega una funci√≥n de modo aleatorio vs. modo seguro (uno genera un solo camino, el otro m√∫ltiples rutas).

Implementa una interfaz por consola donde el usuario pueda explorar el laberinto manualmente antes de activar el solucionador autom√°tico.

¬øQuieres ir m√°s all√°? Crea un modo visual animado en consola que muestre paso a paso c√≥mo se resuelve el laberinto.

üöÄ El C√≥digo Tiene Salida‚Ä¶ Si Sabes Buscarla
Los muros no son el enemigo. La confusi√≥n, s√≠.
Con C como tu br√∫jula y tu l√≥gica como linterna, crea un sistema que no solo construya laberintos, sino que tambi√©n sepa c√≥mo salir de ellos.

Porque en Penguin Academy no solo escribimos l√≠neas de c√≥digo...
Tambi√©n escribimos historias que se compilan.
